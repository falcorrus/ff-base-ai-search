Автор: [Erkebulan](https://t.me/zhappar01) 

**SearchText** — кастомный виджет для подсветки текста в FlutterFlow

Этот кастомный виджет SearchText позволяет выделять искомые слова или отдельные буквы в строке текста. Он поддерживает поиск независимо от порядка слов, а также позволяет находить последовательности символов внутри слов, сохраняя пробелы в тексте.

### Основные возможности:
- Подсветка одного или нескольких слов в тексте.
- Поиск с учетом последовательности букв, включая пробелы.
- Гибкость в настройке размеров виджета (ширина и высота).
- Поддержка FlutterFlow тем для стилизации текста.
- Автоматическая обработка регистра (поиск регистронезависимый).

### Как использовать:
1) Создайте новый Custom Widget в FlutterFlow.
2) Wigdet name SearchText
3) Укажите текст (fullText) и строку поиска (searchText).
Настройте размеры при необходимости.

![[image_search1.mp4]]

### Первый вариант кода
[[Search Symbols.txt]]
```dart
// Automatic FlutterFlow imports
import '/flutter_flow/flutter_flow_theme.dart';
import '/flutter_flow/flutter_flow_util.dart';
import '/custom_code/widgets/index.dart'; // Imports other custom widgets
import '/custom_code/actions/index.dart'; // Imports custom actions
import '/flutter_flow/custom_functions.dart'; // Imports custom functions
import 'package:flutter/material.dart';
// Begin custom widget code
// DO NOT REMOVE OR MODIFY THE CODE ABOVE!

class SearchText extends StatefulWidget {
  const SearchText({
    super.key,
    this.width,
    this.height,
    required this.fullText,
    this.searchText,
  });

  final double? width;
  final double? height;
  final String fullText;
  final String? searchText;

  @override
  State<SearchText> createState() => _SearchTextState();
}

class _SearchTextState extends State<SearchText> {
  List<TextSpan> _getHighlightedSpans() {
    if (widget.searchText == null || widget.searchText!.trim().isEmpty) {
      return [
        TextSpan(
          text: widget.fullText,
          style: FlutterFlowTheme.of(context).bodyMedium,
        ),
      ];
    }

    ````final searchText = widget.searchText!.toLowerCase().trim();````
    ````final fullTextLower = widget.fullText.toLowerCase();````

    ````List<TextSpan> spans = [];````
    ````int startIndex = 0;````

    ````while (startIndex < widget.fullText.length) {````
      ````final index = fullTextLower.indexOf(searchText, startIndex);````

      ````if (index == -1) {````
        ````// Добавляем оставшуюся часть текста без выделения````
        ````spans.add(TextSpan(````
          ````text: widget.fullText.substring(startIndex),````
          ````style: FlutterFlowTheme.of(context).bodyMedium,````
        ````));````
        ````break;````
      ````}````

      ````// Добавляем текст перед совпадением````
      ````if (index > startIndex) {````
        ````spans.add(TextSpan(````
          ````text: widget.fullText.substring(startIndex, index),````
          ````style: FlutterFlowTheme.of(context).bodyMedium,````
        ````));````
      ````}````

      ````// Выделяем совпавшую часть текста````
      ````spans.add(TextSpan(````
        ````text: widget.fullText.substring(index, index + searchText.length),````
        ````style: FlutterFlowTheme.of(context).bodyMedium.copyWith(````
              ````backgroundColor: Colors.yellow,````
              ````color: Colors.black,````
            ````),````
      ````));````

      ````startIndex = index + searchText.length;````
    ````}````

    ````return spans;````
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      width: widget.width ?? double.infinity,
      height: widget.height ?? 50.0, // Высота по умолчанию
      constraints: const BoxConstraints(
        minHeight: 20.0, // Минимальная высота для избежания ошибок компоновки
      ),
      child: RichText(
        text: TextSpan(
          children: _getHighlightedSpans(),
          style: FlutterFlowTheme.of(context).bodyMedium,
        ),
        overflow: TextOverflow.ellipsis,
      ),
    );
  }
}
```



### Второй вариант кода. 
 Тут выделение и поиск по словам
![[SearchWords.mp4]]

[[Search Words.txt]]

```
// Automatic FlutterFlow imports
import '/flutter_flow/flutter_flow_theme.dart';
import '/flutter_flow/flutter_flow_util.dart';
import '/custom_code/widgets/index.dart'; // Imports other custom widgets
import '/custom_code/actions/index.dart'; // Imports custom actions
import '/flutter_flow/custom_functions.dart'; // Imports custom functions
import 'package:flutter/material.dart';
// Begin custom widget code
// DO NOT REMOVE OR MODIFY THE CODE ABOVE!


// Выделение по словам

class SearchText extends StatefulWidget {
  const SearchText({
    super.key,
    this.width,
    this.height,
    required this.fullText,
    this.searchText,
  });


  final double? width;
  final double? height;
  final String fullText;
  final String? searchText;


  @override
  State<SearchText> createState() => _SearchTextState();
}
class _SearchTextState extends State<SearchText> {
  List<TextSpan> _getHighlightedSpans() {
    if (widget.searchText == null || widget.searchText!.trim().isEmpty) {
      return [
        TextSpan(
          text: widget.fullText,
          style: FlutterFlowTheme.of(context).bodyMedium,
        ),
      ];
    }
    final searchWords = widget.searchText!
        .toLowerCase()
        .trim()
        .split(RegExp(r'\s+')); // Разделяем поисковый текст по пробелам
    final fullWords =
        widget.fullText.split(' '); // Разделяем по пробелам с их сохранением
    List<TextSpan> spans = [];
    for (int i = 0; i < fullWords.length; i++) {
      String word = fullWords[i];
      if (searchWords.contains(word.toLowerCase())) {
        spans.add(TextSpan(
          text: word,
          style: FlutterFlowTheme.of(context).bodyMedium.copyWith(
                backgroundColor: Colors.yellow,
                color: Colors.black,
              ),
        ));
      } else {
        spans.add(TextSpan(
          text: word,
          style: FlutterFlowTheme.of(context).bodyMedium,
        ));
      }
      // Добавляем пробел между словами, кроме последнего
      if (i < fullWords.length - 1) {
        spans.add(TextSpan(
          text: ' ', // Восстанавливаем пробелы между словами
          style: FlutterFlowTheme.of(context).bodyMedium,
        ));
      }
    }
    return spans;
  }
  @override
  Widget build(BuildContext context) {
    return Container(
      width: widget.width ?? double.infinity,
      height: widget.height ?? 50.0, // Высота по умолчанию
      constraints: BoxConstraints(
        minHeight: 20.0, // Минимальная высота для избежания ошибок компоновки
      ),
      child: RichText(
        text: TextSpan(
          children: _getHighlightedSpans(),
          style: FlutterFlowTheme.of(context).bodyMedium,
        ),
        overflow: TextOverflow.ellipsis,
      ),
    );
  }
}
```
