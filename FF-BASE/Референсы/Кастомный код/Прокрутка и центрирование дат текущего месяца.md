от [Broz](https://t.me/brozaurus)

## Назначение кастомного виджета
В отличие от стандартного решения с контейнером, засунутым в пролистываемый Row:
- показывается только текущий месяц
- автоматически текущая дата
- выбранная дата центрируется
- выбранная дата сохраняется в AppState
### Как выглядит
каждая дата 56px на 56. Между ними 4. Можно меня в коде (если найдёте, где).
![[2025-02-07_datePicker.jpg]]


### создаём кастомный виджет DateScrollPicker

> [!NOTE] Не забыть
> создать appState "DateScrollPicker"

```dart
// Automatic FlutterFlow imports
import '/backend/backend.dart';
import '/backend/schema/structs/index.dart';
import '/flutter_flow/flutter_flow_theme.dart';
import '/flutter_flow/flutter_flow_util.dart';
import '/custom_code/widgets/index.dart'; // Imports other custom widgets
import '/flutter_flow/custom_functions.dart'; // Imports custom functions
import 'package:flutter/material.dart';
// Begin custom widget code
// DO NOT REMOVE OR MODIFY THE CODE ABOVE!

class DateScrollPicker extends StatefulWidget {
  final DateTime? initialDate;
  final Color? selectedDateColor;
  final Color? unselectedDateColor;
  final double? height;
  final double? width;

  const DateScrollPicker({
    Key? key,
    this.initialDate,
    this.selectedDateColor,
    this.unselectedDateColor,
    this.height = 80,
    this.width,
  }) : super(key: key);

  @override
  _DateScrollPickerState createState() => _DateScrollPickerState();
}

class _DateScrollPickerState extends State<DateScrollPicker> {
  late ScrollController _scrollController;
  late List<DateTime> _dates;
  final double _itemWidth = 56.0;

  @override
  void initState() {
    super.initState();
    _dates = _generateDatesForCurrentMonth();
    _scrollController = ScrollController();

    // Центрируем выбранную дату после инициализации
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _centerSelectedDate();
    });
  }

  List<DateTime> _generateDatesForCurrentMonth() {
    final now = FFAppState().SelectedDate ??
        DateTime.now(); // Используем глобальное состояние
    final lastDay = DateTime(now.year, now.month + 1, 0);

    return List.generate(
      lastDay.day,
      (index) => DateTime(now.year, now.month, index + 1),
    );
  }

  void _centerSelectedDate() {
    if (!mounted) return;

    final selectedDate = FFAppState().SelectedDate ??
        DateTime.now(); // Используем глобальное состояние
    final index = _dates.indexWhere((date) =>
        date.year == selectedDate.year &&
        date.month == selectedDate.month &&
        date.day == selectedDate.day);

    if (index != -1) {
      final screenWidth = MediaQuery.of(context).size.width;
      final offset = max(
        0.0,
        (index * (_itemWidth + 8)) - (screenWidth / 2) + (_itemWidth / 2) + 4,
      );

      _scrollController.animateTo(
        offset,
        duration: const Duration(milliseconds: 300),
        curve: Curves.easeInOut,
      );
    }
  }

  void _scrollToDate(DateTime date) {
    final index = _dates.indexOf(date);
    if (index != -1) {
      final screenWidth = MediaQuery.of(context).size.width;
      final offset = max(
        0.0,
        (index * (_itemWidth + 8)) - (screenWidth / 2) + (_itemWidth / 2),
      );

      _scrollController.animateTo(
        offset,
        duration: const Duration(milliseconds: 300),
        curve: Curves.easeInOut,
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final selectedDate = FFAppState().SelectedDate ??
        DateTime.now(); // Используем глобальное состояние

    // Центрируем выбранную дату при каждом обновлении виджета
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _centerSelectedDate();
    });

    return SizedBox(
      height: widget.height ?? 80,
      child: ListView.builder(
        controller: _scrollController,
        scrollDirection: Axis.horizontal,
        itemCount: _dates.length,
        itemBuilder: (context, index) {
          final date = _dates[index];
          final isSelected =
              date.day == selectedDate.day; // Используем глобальное состояние

          return GestureDetector(
            onTap: () {
              FFAppState().update(() {
                FFAppState().SelectedDate =
                    date; // Обновляем глобальное состояние
              });
              _scrollToDate(date);
            },
            child: Container(
              width: 56,
              height: 56,
              margin: const EdgeInsets.symmetric(horizontal: 4),
              decoration: BoxDecoration(
                color: FlutterFlowTheme.of(context).primaryBackground,
                borderRadius: BorderRadius.circular(16),
                border: Border.all(
                  color: const Color(0xFFE5E7EB),
                  width: 1,
                ),
              ),
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Text(
                    date.day.toString(),
                    style: TextStyle(
                      color: isSelected
                          ? const Color(0xFF2F40FB)
                          : FlutterFlowTheme.of(context).primaryText,
                      fontSize: 18,
                    ),
                  ),
                  Text(
                    _getWeekdayShort(date.weekday),
                    style: TextStyle(
                      color: isSelected
                          ? const Color(0xFF2F40FB)
                          : FlutterFlowTheme.of(context).secondaryText,
                      fontSize: 14,
                    ),
                  ),
                ],
              ),
            ),
          );
        },
      ),
    );
  }

  String _getWeekdayShort(int weekday) {
    switch (weekday) {
      case 1:
        return 'пн';
      case 2:
        return 'вт';
      case 3:
        return 'ср';
      case 4:
        return 'чт';
      case 5:
        return 'пт';
      case 6:
        return 'сб';
      case 7:
        return 'вс';
      default:
        return '';
    }
  }

  @override
  void dispose() {
    _scrollController.dispose();
    super.dispose();
  }
}
```

### Настройки виджета
> [!NOTE] Все могут быть Nullable

![[2025-02-07_dateScrollPicker.jpg]]