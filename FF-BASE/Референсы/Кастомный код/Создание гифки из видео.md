от @sabikrus


# Код
```dart
import 'dart:ui' as ui;
import 'dart:math' as math;

class DrawingCanvas extends StatefulWidget {
  const DrawingCanvas({
    super.key,
    this.width,
    this.height,
    required this.type,
    required this.color,
    required this.history,
    required this.changeHistory,
    required this.size,
    this.allowAdding = true,
    this.brushOpacity = 0.7,
    this.eraserRadius = 30.0, // Радиус действия ластика
  });

  final double? width;
  final double? height;
  final String type;
  final Color color;
  final int history;
  final Future Function(int number) changeHistory;
  final double size;
  final bool allowAdding;
  final double brushOpacity;
  final double eraserRadius;

  @override
  State<DrawingCanvas> createState() => _DrawingCanvasState();
}

class _DrawingCanvasState extends State<DrawingCanvas> {
  List<Map<String, dynamic>> elements = [];
  int historyIndex = 0;
  bool isLoaded = false;

  @override
  void initState() {
    super.initState();
    historyIndex = widget.history;

    // Симулируем загрузку виджета
    Future.delayed(const Duration(milliseconds: 200), () {
      setState(() {
        isLoaded = true;
      });
    });
  }

  void _addElement(Map<String, dynamic> element) {
    if (!widget.allowAdding) return;

    setState(() {
      if (historyIndex < elements.length) {
        elements = elements.sublist(0, historyIndex);
      }
      elements.add(element);
      historyIndex++;
    });

    widget.changeHistory(historyIndex);
  }

  @override
  void didUpdateWidget(covariant DrawingCanvas oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (widget.history != historyIndex) {
      setState(() {
        historyIndex = widget.history.clamp(0, elements.length);
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return RepaintBoundary(
      child: Stack(
        children: [
          if (!isLoaded)
            Center(child: CircularProgressIndicator()), // Индикатор загрузки
          if (isLoaded)
            GestureDetector(
              onPanStart: (details) {
                final localPosition = details.localPosition;
                if (widget.type == 'delete') {
                  _handleEraser(localPosition);
                  return;
                }

                if (!widget.allowAdding) return;

                switch (widget.type) {
                  case 'brush':
                  case 'pencil':
                  case 'pen':
                    _addElement({
                      'type': widget.type,
                      'points': [localPosition],
                      'color': widget.color,
                      'size': widget.size,
                      'opacity': widget.brushOpacity,
                    });
                    break;
                  case 'arrow':
                  case 'line':
                  case 'point':
                  case 'square':
                  case 'circle':
                    _addElement({
                      'type': widget.type,
                      'start': localPosition,
                      'end': localPosition,
                      'color': widget.color,
                      'size': widget.size,
                    });
                    break;
                }
              },
              onPanUpdate: (details) {
                final localPosition = details.localPosition;
                if (widget.type == 'delete') {
                  _handleEraser(localPosition);
                  return;
                }

                if (!widget.allowAdding) return;
                setState(() {
                  if (widget.type == 'brush' 
                      widget.type == 'pencil' 
                      widget.type == 'pen') {
                    elements.last['points'] =
                        List<Offset>.from(elements.last['points'])
                          ..add(localPosition);
                  } else {
                    elements.last['end'] = localPosition;
                  }
                });
              },
              child: CustomPaint(
                size: Size(widget.width ?? double.infinity,
                    widget.height ?? double.infinity),
                painter: _DrawingPainter(
                  elements: elements,
                  historyIndex: historyIndex,
                ),
              ),
            ),
        ],
      ),
    );
  }

  void _handleEraser(Offset position) {
    final radius = widget.eraserRadius;
    setState(() {
      elements.removeWhere((element) {
        if (element['type'] == 'brush' 
            element['type'] == 'pencil' 
            element['type'] == 'pen') {
          return _pointsWithinRadius(
              element['points'] as List<Offset>, position, radius);
        } else {
          return _pointInElement(position, element);
        }
      });
    });
    widget.changeHistory(elements.length);
  }

  bool _pointsWithinRadius(
      List<Offset> points, Offset position, double radius) {
    return points.any((point) => (point - position).distance <= radius);
  }

  bool _pointInElement(Offset point, Map<String, dynamic> element) {
    if (element['type'] == 'line'  element['type'] == 'arrow') {
      return _pointNearLine(point, element['start'], element['end']);
    } else if (element['type'] == 'square'  element['type'] == 'circle') {
      final rect = Rect.fromPoints(element['start'], element['end']);
      return rect.contains(point);
    }
    return false;
  }

  bool _pointNearLine(Offset point, Offset start, Offset end,
      [double threshold = 10.0]) {
    final distance = (point.dx - start.dx) * (end.dy - start.dy) -
        (point.dy - start.dy) * (end.dx - start.dx);
    final lineLength = math
        .sqrt(math.pow(end.dx - start.dx, 2) + math.pow(end.dy - start.dy, 2));
    return (distance / lineLength).abs() < threshold &&
        (point - start).distance + (point - end).distance <=
            lineLength + threshold;
  }
}

class _DrawingPainter extends CustomPainter {
  final List<Map<String, dynamic>> elements;
  final int historyIndex;

  _DrawingPainter({required this.elements, required this.historyIndex});

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()..isAntiAlias = true;

    for (int i = 0; i < historyIndex && i < elements.length; i++) {
      final element = elements[i];
      paint
        ..color = element['color']
            .withOpacity(element['type'] == 'brush' ? element['opacity'] : 1.0)
        ..strokeWidth = element['size']
        ..style = PaintingStyle.stroke;

      if (element['type'] == 'brush') {
        paint
          ..style = PaintingStyle.stroke
          ..maskFilter = const ui.MaskFilter.blur(ui.BlurStyle.normal, 5.0);
      } else {
        paint.maskFilter = null;
      }

      switch (element['type']) {
        case 'brush':
        case 'pencil':
        case 'pen':
          for (int j = 0; j < element['points'].length - 1; j++) {
            canvas.drawLine(
                element['points'][j], element['points'][j + 1], paint);
          }
          break;
        case 'line':
          canvas.drawLine(element['start'], element['end'], paint);
          break;
        case 'arrow':
          _drawArrow(canvas, paint, element);
          break;
        case 'square':
          final rect = Rect.fromPoints(element['start'], element['end']);
          canvas.drawRect(rect, paint);
          break;
        case 'circle':
          final rect = Rect.fromPoints(element['start'], element['end']);
          canvas.drawOval(rect, paint);
          break;
      }
    }
  }
  void _drawArrow(Canvas canvas, Paint paint, Map<String, dynamic> element) {
    final start = element['start'] as Offset;
    final end = element['end'] as Offset;

    canvas.drawLine(start, end, paint);

    final angle = math.atan2(end.dy - start.dy, end.dx - start.dx);
    const arrowLength = 10.0;
    const arrowAngle = math.pi / 6;

    final path = Path()
      ..moveTo(end.dx, end.dy)
      ..lineTo(
        end.dx - arrowLength * math.cos(angle - arrowAngle),
        end.dy - arrowLength * math.sin(angle - arrowAngle),
      )
      ..moveTo(end.dx, end.dy)
      ..lineTo(
        end.dx - arrowLength * math.cos(angle + arrowAngle),
        end.dy - arrowLength * math.sin(angle + arrowAngle),
      );

    canvas.drawPath(path, paint);
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => true;
}

Виджет для рисования или для подписи final String type;
  final Color color; - 'brush' это типо кисточки,'pencil'- это тонкая линия, 'pen': типо ручки. 
  final int history; это показывать предыдущие точки если открываете файл сохраненный.
  final Future Function(int number) changeHistory; это функция для сохранения
  final double size; это ширина
  final bool allowAdding; - можно ли рисовать или только показывать
  final double brushOpacity; это размытие
  final double eraserRadius;  это радиус (но я не помню какой)))))
  import 'dart:io';
import 'package:video_thumbnail/video_thumbnail.dart';
import 'package:image/image.dart' as img;
import 'package:path_provider/path_provider.dart';

Future<FFUploadedFile?> gifFromVideo(FFUploadedFile video) async {
  // Путь для сохранения временных кадров и GIF
  final tempDir = await getTemporaryDirectory();
  final gifPath = '${tempDir.path}/${video.name?.split('.').first}.gif';

  final List<img.Image> frames = [];
  final int fps = 5; // Частота кадров для GIF
  final int maxDurationSeconds = 7; // Максимальная длительность GIF (7 секунд)
  final int maxFrames = fps * maxDurationSeconds; // Максимальное число кадров

  try {
    // Сохранение видеофайла
    final videoFile = File('${tempDir.path}/${video.name}');
    await videoFile.writeAsBytes(video.bytes!);

    if (!videoFile.existsSync()) {
      throw Exception('Видео файл не создан');
    }

    // Интервал между кадрами
    const videoDurationMs = 7000; // Установленная длительность видео
    final int frameIntervalMs = videoDurationMs ~/ maxFrames;

    // Извлечение кадров
    for (int i = 0; i < maxFrames; i++) {
      final framePath = await VideoThumbnail.thumbnailFile(
        video: videoFile.path,
        timeMs: i * frameIntervalMs,
        quality: 40, // Уменьшенное качество кадров
      );

      if (framePath == null) {
        throw Exception('Не удалось создать кадр на ${i * frameIntervalMs} мс');
      }

      final frameBytes = await File(framePath).readAsBytes();
      final frameImage = img.decodeImage(frameBytes);

      if (frameImage == null) {
        throw Exception('Не удалось декодировать изображение для кадра $i');
      }

      // Уменьшаем разрешение
      final aspectRatio = frameImage.width / frameImage.height;
      final targetWidth = 240; // Сниженное разрешение
      final targetHeight = (targetWidth / aspectRatio).round();
      final resizedFrame = img.copyResize(
        frameImage,
        width: targetWidth,
        height: targetHeight,
        interpolation: img.Interpolation.average,
      );
      frames.add(resizedFrame);
    }

    if (frames.isEmpty) {
      throw Exception('Не удалось добавить кадры в GIF');
    }

    // Создание GIF
    final gifEncoder = img.GifEncoder(repeat: 0); // Повторение бесконечно
    for (final frame in frames) {
      gifEncoder.addFrame(frame,
          duration: (1000 ~/ fps)); // Длительность каждого кадра
    }

    final gifBytes = gifEncoder.finish();

    if (gifBytes == null) {
      throw Exception('Не удалось завершить создание GIF');
    }

    // Сохранение GIF
    final gifFile = File(gifPath)..writeAsBytesSync(gifBytes);

    return FFUploadedFile(
      name: gifFile.path.split('/').last,
      bytes: await gifFile.readAsBytes(),
    );
  } catch (e) {
    print('Ошибка: $e');
    return null;
  }
}
```
