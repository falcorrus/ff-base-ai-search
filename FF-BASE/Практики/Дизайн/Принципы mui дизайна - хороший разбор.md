---
status: позже
---
[принципы mui дизайна хороший разбор](https://habr.com/ru/companies/tbank/articles/883438/)

# UX для frontend на основе дизайн-принципов MUI

Простой
9 мин
3.3K

[Блог компании Т-Банк](https://habr.com/ru/companies/tbank/articles/)[Дизайн](https://habr.com/ru/hubs/design/)


![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/5d5/43f/4d7/5d543f4d7a39f1ad1b7d8d69c57b3534.jpg)

Привет, Хабр! Меня зовут Александр, я работаю frontend-разработчиком в Т-Банке. В этой статье я расскажу о UX (User Experience) на основе MUI (Material User Interface): исследую интересные практики и покажу, какие элементы UI можно использовать, чтобы улучшить UX.  
  
Статья — выжимка из документации MUI по их принципам дизайна. Обратите внимание, что в статье нет акцента на особенностях UX, присущих MUI, но выделена полезная информация, которую можно использовать вне рамок MUI:  
  
— поверхности;  
— раскладка;  
— сжатие;  
— цвета;  
— темная тема;  
— показ ошибок.

## Поверхности

Мне приходилось участвовать в обсуждении дизайна, когда созданные интерфейсы внезапно начинали «мозолить глаз» и нужно было найти ответ на вопрос, что не так.  
  
К примеру, такой дизайн был в одном из разрабатываемых мной приложений.

![Тень и граница у верхней панели приводили к лишней визуальной нагрузке](https://habrastorage.org/r/w1560/getpro/habr/upload_files/870/835/ad4/870835ad41d1bc7e960e0051e532b9d7.png "Тень и граница у верхней панели приводили к лишней визуальной нагрузке")

Тень и граница у верхней панели приводили к лишней визуальной нагрузке

Вид верхней панели казался странным, но я не мог понять почему. Как раз в то время, по счастливой случайности, я ознакомился с концепциями поверхностей в MUI и понял, что в верхней панели попросту использовалось слишком много разграничителей: через тень и границу. Я убрал границы и оставил только тень.

![Панель без границы стала более «легкой»](https://habrastorage.org/r/w1560/getpro/habr/upload_files/fed/08b/c92/fed08bc927d13aa838f8cd79472d538b.png "Панель без границы стала более «легкой»")

Панель без границы стала более «легкой»

Панель будто бы вырвалась из оков границ, удалось сбросить лишнюю нагрузку с интерфейса.

Концепция показа областей интерфейса в MUI основана на том, что отображение элементов разбивается на определенные поверхности. При этом каждая поверхность может отделяться от другой на основе трехмерных координат с помощью света, поверхности и теней. Наиболее важную роль в выделении поверхностей играют тени, потому что они позволяют задавать высоту по Z-оси.

![Тень отделяет одну поверхность от другой. Источник иллюстрации](https://habrastorage.org/r/w1560/getpro/habr/upload_files/6f4/d59/cca/6f4d59cca184b77ebc9132c2182d87c8.jpg "Тень отделяет одну поверхность от другой. Источник иллюстрации")

Тень отделяет одну поверхность от другой. [Источник иллюстрации](https://m2.material.io/design/environment/surfaces.html#material-environment)

Тени позволяют выделять более важные и менее важные поверхности, помогают пользователю легче найти информацию, подчеркивают интерактивность элемента. Например, если взглянуть на диаграмму поверхностей, можно увидеть, что у диалогового окна наибольший приоритет по высоте по сравнению с другими поверхностями.

![Диаграмма высоты поверхностей. Источник иллюстрации](https://habrastorage.org/r/w1560/getpro/habr/upload_files/2f3/9a2/089/2f39a208958d9dd1080ac5d5b3691a73.png "Диаграмма высоты поверхностей. Источник иллюстрации")

Диаграмма высоты поверхностей. [Источник иллюстрации](https://m2.material.io/design/environment/elevation.html#default-elevations)

Элементы с равной высотой через тени расцениваются как равные по приоритету.

![Диалоговое окно находится на том же уровне важности, что и текст. Источник иллюстрации](https://habrastorage.org/r/w1560/getpro/habr/upload_files/7b4/3bb/81a/7b43bb81afdb6224fd20db82b3225380.jpg "Диалоговое окно находится на том же уровне важности, что и текст. Источник иллюстрации")

Диалоговое окно находится на том же уровне важности, что и текст. [Источник иллюстрации](https://m2.material.io/design/environment/elevation.html#depicting-elevation) 

Затенение фона (skimming) выделяет поверхность по приоритету, но не подчеркивает изменение высоты по Z-оси.

![Диалоговое окно акцентирует внимание на себе. Источник иллюстрации](https://habrastorage.org/r/w1560/getpro/habr/upload_files/2db/3e4/d7c/2db3e4d7cbe04e7d9b163af28be5bb99.png "Диалоговое окно акцентирует внимание на себе. Источник иллюстрации")

Диалоговое окно акцентирует внимание на себе. [Источник иллюстрации](https://m2.material.io/design/environment/elevation.html#depicting-elevation)

Но не стоит злоупотреблять тенями и «навешивать» их на обычные элементы.

![Выделение изображения тенями приводит к необоснованному акценту на нем. Источник иллюстрации](https://habrastorage.org/r/w1560/getpro/habr/upload_files/e4f/aed/361/e4faed3611246580b161f1df9cc1585f.png "Выделение изображения тенями приводит к необоснованному акценту на нем. Источник иллюстрации")

Выделение изображения тенями приводит к необоснованному акценту на нем. [Источник иллюстрации](https://m2.material.io/design/environment/elevation.html#depicting-elevation)

## Раскладка

Важная составляющая раскладки — консистентность отступов, правильное масштабирование и привычный вид, который знаком большинству пользователей, так называемый закон Якоба. Закон гласит, что пользователи имеют модель мышления, которая сформировалась на основе использования других систем. То есть они ожидают от новой системы похожего поведения. Например, раскладка с панелью сверху, навигацией сбоку и контентом внизу смотрится привычно.

![Раскладка, скорее всего, знакомая многим. Источник иллюстрации](https://habrastorage.org/r/w1560/getpro/habr/upload_files/50e/5bd/10f/50e5bd10f90dd7ae085bef9164c5ef72.png "Раскладка, скорее всего, знакомая многим. Источник иллюстрации")

Раскладка, скорее всего, знакомая многим. [Источник иллюстрации](https://m2.material.io/design/layout/understanding-layout.html#composition)

Панель приложения в раскладке может служить для показа часто используемой или приоритетной информации и функциональности.

![Примеры отображения элементов в панели приложения. Источник иллюстрации](https://habrastorage.org/r/w1560/getpro/habr/upload_files/f4e/5d6/629/f4e5d6629da3768005ddca0d99d5cfa1.png "Примеры отображения элементов в панели приложения. Источник иллюстрации")

Примеры отображения элементов в панели приложения. [Источник иллюстрации](https://m3.material.io/components/top-app-bar/guidelines)

Для отделения панели приложения от других поверхностей приложения можно использовать заливку фона, границы или изменение высоты через тени.

Панель навигации может иметь свернутый и развернутый вид. При больших разрешениях монитора удобнее показывать панель в развернутом виде, а при маленьких разрешениях это может быть модальная панель навигации, которая при раскрытии может перекрывать контент (skimming).

![Модальная панель навигации. Источник иллюстрации](https://habrastorage.org/r/w1560/getpro/habr/upload_files/267/758/d08/267758d0861909897bcf985e2ae6b39a.png "Модальная панель навигации. Источник иллюстрации")

Модальная панель навигации. [Источник иллюстрации](https://m2.material.io/design/layout/understanding-layout.html#layout-anatomy)

На мобильных устройствах можно вынести часто используемые действия или навигацию в нижнюю панель.

![Нижняя панель с действиями. Источник иллюстрации](https://habrastorage.org/r/w1560/getpro/habr/upload_files/a2a/79b/6a1/a2a79b6a19e6dfbe4d3c6b9c70770676.png "Нижняя панель с действиями. Источник иллюстрации")

Нижняя панель с действиями. [Источник иллюстрации](https://m3.material.io/components/bottom-app-bar/overview) 

Способ отображения основного контента играет важную роль, поэтому очень полезно группировать элементы. Группировку можно сделать по принципу схожести. Например, карточки с одинаковой внутренней раскладкой и типографикой будут восприниматься как одна группа.

![Пример визуальной группировки карточек. Источник иллюстрации](https://habrastorage.org/r/w1560/getpro/habr/upload_files/efb/c76/a6f/efbc76a6fb07be2519c06b25c8500659.png "Пример визуальной группировки карточек. Источник иллюстрации")

Пример визуальной группировки карточек. [Источник иллюстрации](https://m2.material.io/design/layout/understanding-layout.html#composition)

Если же элементы различаются визуально, можно использовать группировку с помощью уменьшения отступов между элементами, которые нужно сгруппировать, и увеличения между группами элементов — так называемую неявную группировку.

![Заголовки и описания статей сгруппированы через отступы. Источник иллюстрации)](https://habrastorage.org/r/w1560/getpro/habr/upload_files/0fe/556/b7f/0fe556b7f35e647467cb5c1a02346f95.png "Заголовки и описания статей сгруппированы через отступы. Источник иллюстрации)")

Заголовки и описания статей сгруппированы через отступы. [Источник иллюстрации](https://m2.material.io/design/layout/understanding-layout.html#composition))

Можно использовать явную группировку через установку границ для группы элементов или изменение высоты через тени.

![Каждый элемент явно отделен от другого границей. Источник иллюстрации](https://habrastorage.org/r/w1560/getpro/habr/upload_files/526/d76/7d3/526d767d3af1614b2afc2dc75439eeba.png "Каждый элемент явно отделен от другого границей. Источник иллюстрации")

Каждый элемент явно отделен от другого границей. [Источник иллюстрации](https://m2.material.io/design/layout/understanding-layout.html#composition) 

В MUI есть таблица, которая помогает определить поведение и отображение компонентов при изменении размеров экрана:

|   |   |   |   |
|---|---|---|---|
|Тип компонента|Мобильное отображение|Планшетное отображение|Десктопное отображение|
|Навигация (вариант 1)|Нижняя навигация|Шторка навигации (navigation rail)|Боковая панель|
|Навигация (вариант 2)|Модальная панель навигации|Модальная панель навигации|Открытая боковая панель|
|Коммуникация|Полноэкранное модальное окно|Модальное окно|Модальное окно|
|Действия|Нижняя панель|Меню|Меню|

## Сжатие

Сжатие тесно связано с плотностью размещения элементов, ведь на маленьких экранах сжатие можно применять на большом количестве однообразной информации — таблицах, формах, списках, чтобы улучшить читаемость и фокусировку на контенте.

Задачи, подразумевающие интерактивность, и компоненты, основанные на уведомлениях, не должны применять сжатие. Например, увеличение сжатия в диалоговом окне уменьшает фокусировку, читаемость и важность.

![Высокая степень сжатия приводит к ухудшению работы с модальным окном. Источник иллюстрации](https://habrastorage.org/r/w1560/getpro/habr/upload_files/c8c/415/c2d/c8c415c2df3f90af7dfbfc409380025d.png "Высокая степень сжатия приводит к ухудшению работы с модальным окном. Источник иллюстрации")

Высокая степень сжатия приводит к ухудшению работы с модальным окном. [Источник иллюстрации](https://m2.material.io/design/layout/applying-density.html#usage) 

Или, к примеру, слишком сильное сжатие элементов выпадающего меню может привести к тому, что на мобильных устройствах пользователю будет неудобно выбирать опции. Подобные правила описаны законом Фиттса: интерактивные элементы должны быть большими, иметь большое расстояние между собой и быть легко находимыми.

Компоненты с большим сжатием должны иметь более крупные внешние и внутренние отступы.

![Чем выше степень сжатия, тем больше внешние отступы. Источник иллюстрации](https://habrastorage.org/r/w1560/getpro/habr/upload_files/a2e/e58/685/a2ee58685e347a9c9801261f5a443e6a.png "Чем выше степень сжатия, тем больше внешние отступы. Источник иллюстрации")

Чем выше степень сжатия, тем больше внешние отступы. [Источник иллюстрации](https://m2.material.io/design/layout/applying-density.html#layout) 

### Цвета

Основной цвет (primary) чаще всего применяется в приложении для различия UI-элементов между собой:

- Primary-цвет можно по умолчанию применять к кнопкам или, к примеру, к заголовкам, чтобы сделать акцент на них. Нежелательно использовать primary-цвет для обычного текста параграфов.
    
- Secondary-цвета позволяют добавить еще больше особенностей в приложение. Такие цвета можно применять на floating-кнопках, прогресс-барах, заголовках, при выделении текста и так далее.
    

![Бирюзовый secondary-цвет на floating-кнопке. Источник иллюстрации](https://habrastorage.org/r/w1560/getpro/habr/upload_files/5fc/a69/0ab/5fca690ab5b0849984baea3bbfe028b4.png "Бирюзовый secondary-цвет на floating-кнопке. Источник иллюстрации")

Бирюзовый secondary-цвет на floating-кнопке. [Источник иллюстрации](https://m2.material.io/design/color/the-color-system.html#color-theme-creation) 

Цвета могут иметь темные и светлые вариации.

![Фиолетовый primary-цвет использует темный вариант (700) для системной панели сверху. Источник иллюстрации](https://habrastorage.org/r/w1560/getpro/habr/upload_files/176/e20/a63/176e20a635a2c29b2af37366a68be11f.png "Фиолетовый primary-цвет использует темный вариант (700) для системной панели сверху. Источник иллюстрации")

Фиолетовый primary-цвет использует темный вариант (700) для системной панели сверху. [Источник иллюстрации](https://m2.material.io/design/color/the-color-system.html#color-theme-creation) 

Увеличение контраста между цветом фона и элементом на нем может привести к увеличению акцента.

![Выбранные элементы показываются белым, сильно контрастируя с фоном. Источник иллюстрации](https://habrastorage.org/r/w1560/getpro/habr/upload_files/078/b40/7c9/078b407c9ecbc1dddb853e713ae5cbf4.png "Выбранные элементы показываются белым, сильно контрастируя с фоном. Источник иллюстрации")

Выбранные элементы показываются белым, сильно контрастируя с фоном. [Источник иллюстрации](https://m2.material.io/design/color/color-usage.html#hierarchy) 

Если приложение не содержит высококонтрастных цветов, применение контрастного цвета на элементах выделит их и придаст важности.

![Заголовки выделяются на фоне бело-серой палитры приложения. Источник иллюстрации](https://habrastorage.org/r/w1560/getpro/habr/upload_files/546/a78/af8/546a78af8f1926f3c2c5618cefe6eceb.png "Заголовки выделяются на фоне бело-серой палитры приложения. Источник иллюстрации")

Заголовки выделяются на фоне бело-серой палитры приложения. [Источник иллюстрации](https://m2.material.io/design/color/color-usage.html#hierarchy)

Цвета должны консистентно использоваться по всему приложению. Допустим, если для индикации выбора используется secondary-цвет, все подобные индикации должны выделяться этим цветом.

Очевидно, но черный цвет текста рекомендуется использовать на светлом фоне, а белый цвет — на черном.

Вместо использования оттенков серого для цвета текста или иконок на цветном фоне куда лучше применить прозрачность. Так текст будет смотреться более мягко в сочетании с фоном.

![Применение прозрачности к черному тексту слева. Источник иллюстрации](https://habrastorage.org/r/w1560/getpro/habr/upload_files/bee/5da/0ec/bee5da0ecdc80010eeb948eb66b5074c.png "Применение прозрачности к черному тексту слева. Источник иллюстрации")

Применение прозрачности к черному тексту слева. [Источник иллюстрации](https://m2.material.io/design/color/text-legibility.html#text-backgrounds) 

Разный уровень прозрачности текста может показывать определенные состояния. Выделяющийся текст может иметь процент прозрачности около 87%, подсказки и обычный текст — около 60%, но подсказка текста ошибки должна иметь прозрачность 100%. Disabled-текст — около 38%. То же самое можно сказать про иконки.

Следует избегать обильного использования разных цветов в тексте. Такая практика может быть применима для текстов заголовков, кнопок или ссылок, чтобы привлечь внимание пользователя.

Кстати, в MUI есть удобные инструменты [для генерации цветовой палитры](https://m2.material.io/inline-tools/color/) и [генерации темы.](https://zenoo.github.io/mui-theme-creator/)

А MUI 3 предлагает реализацию [динамической генерации цветов](https://m3.material.io/styles/color/dynamic/choosing-a-source) для мобильных устройств.

## Темная тема

Невозможно не упомянуть применение темной темы, когда речь заходит о цветах в приложении.

Принципы построения темной темы:

- оттенки серого лучше, чем черный цвет.
    
- больше темного, чем акцентных и светлых цветов.
    
- важно следить за контрастом, чтобы все было хорошо видно.
    

В темной теме высота поверхностей измеряется яркостью цвета. Чем выше яркость, тем выше поверхность. Для этого создается верхний слой (overlay), который накладывается на поверхность. Overlay на основной слой позволяет увеличить контраст между разными поверхностями и выразить высоту.

![Чем выше поверхность, тем выше яркость overlay над ней. Источник иллюстрации](https://habrastorage.org/r/w1560/getpro/habr/upload_files/095/705/f6b/095705f6b543a9a00214685e9dc3b593.png "Чем выше поверхность, тем выше яркость overlay над ней. Источник иллюстрации")

Чем выше поверхность, тем выше яркость overlay над ней. [Источник иллюстрации](https://m2.material.io/design/color/dark-theme.html#properties) 

Соотношение контраста между текстом и поверхностью должно быть примерно 15,8:1, и это подходит под стандарты WCAG's AA (соотношение текста и фона 4,5:1):

![Пример правильной (сверху) и неправильной (снизу) контрастности в темной теме. Источник иллюстрации](https://habrastorage.org/r/w1560/getpro/habr/upload_files/aac/cd5/b17/aaccd5b178751de7f30b2dee3347343d.png "Пример правильной (сверху) и неправильной (снизу) контрастности в темной теме. Источник иллюстрации")

Пример правильной (сверху) и неправильной (снизу) контрастности в темной теме. [Источник иллюстрации](https://m2.material.io/design/color/dark-theme.html#properties) 

Primary- и secondary-цвета следует использовать с пониженной контрастностью, чтобы избегать напряжения глаз.

![Пример слишком высокой контрастности цвета поверхностей, которая может раздражать глаза. Источник иллюстрации](https://habrastorage.org/r/w1560/getpro/habr/upload_files/5b1/9c6/9b2/5b19c69b2c56ae1c81a968c4f34b4ee3.png "Пример слишком высокой контрастности цвета поверхностей, которая может раздражать глаза. Источник иллюстрации")

Пример слишком высокой контрастности цвета поверхностей, которая может раздражать глаза. [Источник иллюстрации](https://m2.material.io/design/color/dark-theme.html#ui-application)

Еще несколько комментариев: 

- Brand-цвета можно использовать без снижения контрастности, но с осторожностью.
    
- Яркие цвета лучше всего использовать для небольших поверхностей вроде кнопок, переключателей и так далее. Можно применять и поверхности со светлой темой, чтобы выделить их. Например, для модальных окон или уведомлений.
    
- Чем важнее текст, тем менее прозрачным он должен быть.
    

## Показ ошибок. Оптимистичные и пессимистичные обновления

Как правило, приложение с хорошим UX подразумевает не только красивые цвета, удобное расположение кнопок и так далее. Важную роль играет фидбэк от взаимодействия пользователя с приложением.

Если приложение не дает должного фидбэка или дает его с опозданием, пользователь может посчитать, что приложение «тормозит». Подобное восприятие приложения пользователем называют порогом Доэрти: ответная реакция от системы должна быть быстрой, около 400 миллисекунд, иначе система будет казаться медленной. Например, при долгой загрузке изображения можно сначала загрузить его эскиз и размывать это изображение. Или не обязательно ждать отклика от системы — например, на запрос. Можно сразу отобразить желаемый отклик на действие пользователя, а потом уже показать уведомление, когда запрос завершится.

В книге «Дизайн привычных вещей» Норман пишет, что отсутствие фидбэка приводит к разрыву оценки, то есть пользователь не может сопоставить свои ожидания от взаимодействия с приложением.

Но пока что все это теория, и неплохо бы подкрепить слова примерами.

Представим, что приложение не смогло получить права для пользователя при входе в приложение. Что лучше всего показать: дашборд с пустым экраном или уведомление? Например, покажем дашборд, в котором вся функциональность будет заблокирована.

![Пример показа пустого экрана дашборда](https://habrastorage.org/r/w1560/getpro/habr/upload_files/5ca/776/bc2/5ca776bc27e36fb27165588358d60674.png "Пример показа пустого экрана дашборда")

Пример показа пустого экрана дашборда

Система не получила прав пользователя, и это критическая ошибка. На верхнем скриншоте видно, что пользователь не сможет работать с приложением, поэтому нет смысла показывать сломанную функциональность из-за ошибки.

Важно обратить внимание пользователя на эту ошибку и показать диалоговое окно, которое заблокирует дальнейшую работу с приложением и предложит варианты решения проблемы.

![Блокируем дальнейшую работу с приложением и предлагаем варианты решения проблемы](https://habrastorage.org/r/w1560/getpro/habr/upload_files/262/9e4/e7c/2629e4e7cb1eedcc1a2301696c08c577.png "Блокируем дальнейшую работу с приложением и предлагаем варианты решения проблемы")

Блокируем дальнейшую работу с приложением и предлагаем варианты решения проблемы

Уже лучше, но стоит обратить внимание на текст ошибок и не смущать пользователя терминами наподобие «пермишены» и «запрос».

![Пользователю не всегда важно знать технические подробности ошибок](https://habrastorage.org/r/w1560/getpro/habr/upload_files/031/f2e/d52/031f2ed5233c9ce7ded0dbd84886ee9f.png "Пользователю не всегда важно знать технические подробности ошибок")

Пользователю не всегда важно знать технические подробности ошибок

Подобный фидбэк — крайняя мера, потому что он блокирует дальнейшую работу пользователя. К примеру, было бы странным показывать диалоговое окно об ошибке, если в приложении упал запрос на получение подсказок для поля ввода.

В таком случае лучше показать уведомление, которое пользователь может заметить, а может упустить из виду, продолжив работу.

![Не удалось получить подсказки, но продолжить работу можно](https://habrastorage.org/r/w1560/getpro/habr/upload_files/100/d54/9b0/100d549b0171cae3968c0b68b3e20775.png "Не удалось получить подсказки, но продолжить работу можно")

Не удалось получить подсказки, но продолжить работу можно

Не всегда важно ожидать окончания того или иного запроса или процесса в приложении. Для улучшения UX можно сразу показывать результат действия пользователя — это называется оптимистичными обновлениями.

К примеру, такое часто практикуется при отправке сообщений.

![Сначала обновляем UI, потом обрабатываем запрос](https://habrastorage.org/getpro/habr/upload_files/a71/db9/1bf/a71db91bf34a255bad120acc32a4d0f8.gif "Сначала обновляем UI, потом обрабатываем запрос")

Сначала обновляем UI, потом обрабатываем запрос

Куда менее предпочтительно было бы блокировать экран на время загрузки сообщения и показывать диалоговое окно об ошибке, если отправка сообщения провалилась. Это пессимистичное обновление.

![Сначала обрабатываем запрос, потом обновляем UI](https://habrastorage.org/getpro/habr/upload_files/f9d/a8b/c08/f9da8bc085e56aa4ebf2866e3aa80b61.gif "Сначала обрабатываем запрос, потом обновляем UI")

Сначала обрабатываем запрос, потом обновляем UI

## Заключение

Я рассмотрел разные стороны построения UX на основе [дизайн-принципов MUI.](https://m2.material.io/design/introduction)

Благодаря изучению MUI я получил массу полезной информации о UX, которую можно взять за основу, когда возникнут вопросы о построении интерфейсов.

Вот несколько важных для меня выводов: 

- Концепция выделения поверхностей по высоте через тени и подложки (в темной теме) выглядит интересно и вполне может быть применима вне рамок MUI.
    
- При построении раскладки вполне можно будет опираться на таблицу раскладок MUI, упомянутую в статье.
    
- Понимание различия цветов (primary, secondary и так далее) позволит грамотно построить цветовую схему и выдержать цветовое оформление приложения.
    
- Правильный показ ошибок обеспечит хорошее впечатление от пользования приложением и ответит на вопрос, какую ошибку показывать в том или ином случае.
    

А что вы думаете по поводу пользы знания UX для frontend-разработчика? И из каких