---
dg-publish: true
---

**Supabase** и **Firebase** — это платформы, ориентированные на разработчиков, которые предлагают базы данных как услугу, а также дополнительные инструменты для создания бекенда. Основные отличия между ними заключаются в типе базы данных, архитектуре и подходе к обработке данных.

# Видео сравнения
### от John Kealy
[Firebase Vs Supabase: The FlutterFlow User's Guide To Choosing A Backend - YouTube](https://www.youtube.com/watch?v=Jm2QYfdnaNM)


# ! Про цены:
Supabase - хороший бесплатный тариф, позволяющий довольно многое. А тариф за 25$ увеличивает возможности примерно в 10 раз.
У Supabase (в отличии от Firebase) нет отслеживания **количества** скачиваемых данных (запросов). Основной критерий это **объём**. Т.е. при запросе таблицы с кучей полей в Firebase вы вылетите в трубу. А в Supabase важнее, сколько байтов вы скачаете.

Смотреть использовании лимитов надо в Project settings - Usage
# Ключевые отличия Supabase и Firebase (офиц)

1. **Тип базы данных**:
   - **[[Supabase/0! Supabase|0! Supabase]]**: Основывается на **PostgreSQL**, что означает, что это реляционная база данных с поддержкой SQL-запросов. PostgreSQL поддерживает сложные запросы, связи (отношения между таблицами), транзакции и строгую структуру данных.
   - **[[Firebase]]**: В основном использует **NoSQL** базу данных в формате **Firebase Realtime Database** или **Firestore**, где данные хранятся в виде JSON-структур (документов). Эти базы данных более гибкие, но менее строгие в плане схем данных.

2. **Схема данных и типы запросов**:
   - **Supabase**: Строго типизированная структура с поддержкой SQL-запросов и реляционных связей между таблицами. Это делает её подходящей для приложений, которым важна строгая организация данных и работа с транзакциями.
   - **Firebase**: Структура данных гибкая и схему данных можно изменить без миграций. Подходит для приложений с иерархической структурой данных, где данные изменяются динамично и не требуют сложных связей.

3. **Автоматические API**:
   - **Supabase**: Генерирует **REST API** для каждой таблицы и функции в PostgreSQL автоматически. Также поддерживает **real-time** обновления на основе **PostgreSQL LISTEN/NOTIFY**.
   - **Firebase**: Использует собственные SDK и API для взаимодействия с базой данных, также предоставляя **реальное время** через WebSocket. API обрабатывают изменения данных мгновенно, но Firebase работает в основном с JSON.

4. **Хостинг и локальное развертывание**:
   - **Supabase**: Может быть развёрнут локально или на облачных платформах, таких как AWS или DigitalOcean, что даёт гибкость в управлении и настройке окружения.
   - **Firebase**: Полностью управляемый сервис от Google, что ограничивает возможность кастомизации и локального развертывания. Однако это делает его более простым в использовании для небольших и быстро запускаемых проектов.

5. **Аутентификация**:
   - **Supabase**: Предоставляет аутентификацию на базе **GoTrue**, которая поддерживает OAuth, OTP, Magic Links, поддержку нескольких поставщиков (Google, GitHub, Facebook и т.д.).
   - **Firebase**: Firebase Authentication также поддерживает широкие возможности для авторизации через социальные сети, email/password, а также OTP и анонимную авторизацию.

6. **Безопасность данных**:
   - **Supabase**: Поддерживает **Row-Level Security (RLS)** PostgreSQL, что позволяет создавать гибкие правила доступа для строк, таблиц или представлений на основе JWT-токенов.
   - **Firebase**: Использует **правила безопасности Firebase** для управления доступом, которые позволяют задавать правила для чтения и записи на основе пользовательских ролей и путей данных.

7. **Функции**:
   - **Supabase**: Поддерживает **хранимые процедуры, триггеры, и функции** PostgreSQL, что позволяет выполнять сложную логику на уровне базы данных.
   - **Firebase**: Firebase Functions позволяет запускать JavaScript/TypeScript функции на стороне сервера. Это отдельный сервис, который интегрируется с Firebase, но работает вне базы данных.

8. **Поддержка расширенной аналитики**:
   - **Supabase**: PostgreSQL поддерживает сложные аналитические запросы и работу с большими наборами данных. Поддерживает расширения, такие как **PostGIS** для геопространственных запросов.
   - **Firebase**: Ограниченные возможности для аналитики. Firestore поддерживает ограниченный SQL-подобный язык для фильтрации данных, но без возможностей PostgreSQL для выполнения сложных запросов и агрегаций.

# Итак, как выбрать?

- **Supabase** подходит, если:**
  - Вам нужен SQL и строгая структура данных.
  - Ваше приложение требует транзакций, сложных запросов и реляционных связей.
  - Вам нужна возможность развертывания базы данных локально или в облаке по вашему выбору.

- **Firebase подходит, если:**
  - Вы хотите простой в использовании сервис для быстрого прототипирования.
  - Ваши данные могут быть гибко структурированы в формате JSON, без необходимости в сложных связях.
  - Вы хотите использовать полностью управляемое решение от Google и не планируете локальные развертывания.

Каждая из этих платформ имеет свои сильные стороны в зависимости от особенностей проекта и требований к данным.

# Мнения
## @brozaurus
**Я за Supabase**
- В supa удобно смотреть данные в привычной табличной форме.
- Второе, возможно [вынести логику](https://www.youtube.com/watch?v=bi8VbPbBT4o) (или ее часть) из Flutterflow. Все будет работать надёжней и быстрее.
- Есть возможность работать по API
- [[Supabase realtime (обновление базы)|Есть реалтайм обновление базы]]
- Можно развернуть на своём сервере в России и будет не нарушать российский законы о хранении данных и быстрее работать.
- можно использовать [GraphQL](GraphQL.md) для для визуального сбора нашего запроса из разных таблиц
- отлично подходит для векторного поиска, интеграции в n8n

## @darkh1b
Supabase фильтрация происходит прямо в базе данных, что реально снимает нагрузку с устройства и упрощает работу с большими объемами данных. Firebase тоже крутой, но для таких вещей его часто нужно оборачивать в дополнительные костыли или переносить логику на сторону клиента/сервера.

Через cloud functions можете все это сделать, но опять же это сложно так как вам придется писать код на языке JavaScript или TypeScript для реализации логики